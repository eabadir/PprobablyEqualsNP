import PPNP.NumberTheory.Core
import PPNP.Complexity.Program
import Mathlib.Data.Vector.Basic
import Mathlib.Data.Rat.Lemmas
import Mathlib.Data.Fin.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Fintype.Pi
import Mathlib.Data.Fintype.Vector -- Add this import
import Mathlib.Data.Finset.Basic
import Mathlib.Logic.Equiv.Array
import Mathlib.Probability.ProbabilityMassFunction.Basic -- Add this import
import Mathlib.Probability.ProbabilityMassFunction.Constructions -- Add this import
import Mathlib.Probability.ProbabilityMassFunction.Monad -- Add this import
import Mathlib.Data.NNRat.BigOperators
import Mathlib.Control.Random




open Classical

/- Equivalence between the `List.Vector` type used by `Equiv.vectorEquivFin`
    and the `Vector` type (array‐based) that we use for bit blocks. -/
private def listVectorEquivVector {α} {n : ℕ} :
    List.Vector α n ≃ Vector α n :=
{ toFun := fun v =>
    match v with
    | ⟨l, hl⟩ =>
        -- Convert the list to an array and transport the length proof.
        have h_size : (l.toArray).size = n := by
          -- `Array.size_eq_length_toList` tells us the size equals the length of `toList`;
          -- `Array.toList` of `l.toArray` is just `l`.
          simp [Array.size_eq_length_toList, Array.toArray_toList, hl]
        -- Build the `Vector` using the array plus its size proof.
        ⟨l.toArray, h_size⟩,
  invFun := fun v =>
    match v with
    | ⟨a, ha⟩ =>
        -- Convert the array back to a list and transport the length proof.
        have h_len : (a.toList).length = n := by
          -- `ha : a.size = n`, and `Array.size_eq_length_toList` rewrites the size.
          aesop
        ⟨a.toList, h_len⟩,
  left_inv := by
    intro v
    cases v with
    | mk l hl =>
        -- Unfold the constructions; everything reduces to identities on `Array`/`List`.
        simp [Array.size_eq_length_toList, hl],
  right_inv := by
    intro v
    cases v with
    | mk a ha =>
        simp [Array.size_eq_length_toList, ha] }

/-- `Vector Bool k` inherits its `Fintype` structure by transporting the
    canonical `Fintype` on `Fin k → Bool` across the composite equivalence
    ```
    Fin k → Bool  ≃  List.Vector Bool k  ≃  Vector Bool k
    ``` -/
instance instFintypeVectorBool (k : ℕ) : Fintype (Vector Bool k) :=
  Fintype.ofEquiv (Fin k → Bool)
    ((Equiv.vectorEquivFin Bool k).symm.trans listVectorEquivVector)



/-!
# EGPT: Stochastic Filters and Biised IID Sources

This file extends the EGPT number theory to formalize the concept of a "filter"
that acts on a fair, fundamental IID source to produce a new, biased IID source.

The core ideas are:
1.  **Filters as Information:** A filter is a computable object, a set of
    constraints represented by a `GNat` via an encoding of a CNF formula.
    This aligns with the EGPT principle that physical laws are computable information.

2.  **Creating Bias through Information Loss:** The filter operates by rejection
    sampling. It observes samples from the fair source and only "passes" those
    that satisfy its constraints. This many-to-one mapping (many source states
    are rejected, a few are accepted) is the mechanism of information loss that
    creates a new, non-uniform (biased) probability distribution.

3.  **Universality:** We show that this mechanism is universal. Any computable
    rational probability distribution can be generated by applying a sufficiently
    complex filter to the fundamental fair source. The complexity of the filter
    is directly tied to the complexity of the distribution it generates.

This provides a constructive bridge between the uniform chaos of the base IID source
and the structured, biased probabilities observed in complex physical and
computational systems.
-/

namespace PPNP.NumberTheory.Filter

open PPNP.NumberTheory.Core PPNP.Complexity.Program

-- To handle sources that emit blocks of bits (vectors) instead of single bits.
class IIDBlockSource (α : Type) where
  stream : ℕ → α

-- A fair source that produces k-bit vectors, where each vector is equiprobable.
-- This can be constructed by calling a single-bit IIDParticleSource k times.
instance FairBlockSource (k : ℕ) : IIDBlockSource (Vector Bool k) where
  stream := fun n =>
    let baseSource := mkPseudoRandomSource (seed := n)
    -- Generate a k-length list of Bools and convert to a vector
    Vector.ofFn (fun i : Fin k => baseSource.stream i.val)

/-!
### Section 1: Syntactic Filters as CNF Formulas

We reuse the syntactic CNF definitions from `Program.lean`. A filter *is* a
CNF formula, represented by a `GNat`. We define an explicit evaluation function
for these syntactic formulas on boolean vectors.
-/

/--
Evaluates a single syntactic literal against a variable assignment vector.
`assignment.get lit.box_index` fetches the boolean value for the variable.
The literal's polarity determines if we use the value directly or its negation.
-/
def evalLiteral {k : ℕ} (lit : Literal_EGPT k) (assignment : Vector Bool k) : Bool :=
  -- `(assignment.get lit.box_index)` is the value of the variable.
  -- `xor` with `¬lit.polarity` implements the conditional negation:
  -- - If polarity is true (positive literal), `¬polarity` is false. `v xor false = v`.
  -- - If polarity is false (negative literal), `¬polarity` is true. `v xor true = ¬v`.
  xor (assignment.get lit.box_index) (not lit.polarity)

/--
Evaluates a syntactic clause. A clause is satisfied if any of its literals are true.
-/
def evalClause {k : ℕ} (clause : Clause_EGPT k) (assignment : Vector Bool k) : Bool :=
  clause.any (fun lit => evalLiteral lit assignment)

/--
Evaluates a syntactic CNF formula. A formula is satisfied if all of its clauses are true.
This function is the semantic interpreter for our filter.
-/
def evalCNF {k : ℕ} (cnf : SyntacticCNF_EGPT k) (assignment : Vector Bool k) : Bool :=
  cnf.all (fun clause => evalClause clause assignment)

/-!
### Section 2: The Rejection Filter (Uniform Distribution over SAT)

This model represents a filter that accepts any input satisfying its CNF constraints.
The resulting distribution is uniform over the set of satisfying assignments.
-/

/--
A `RejectionFilter` encapsulates a CNF formula, which is encodable as a `GNat`.
This structure represents the physical laws or constraints of a system.
-/
structure RejectionFilter (k : ℕ) where
  /-- The syntactic CNF formula representing the filter's rules. -/
  cnf : SyntacticCNF_EGPT k
  /-- A proof that the filter is satisfiable, ensuring the filtered source can produce output. -/
  is_satisfiable : ∃ (assignment : Vector Bool k), evalCNF cnf assignment




instance instDecidableEqVectorBool (k : ℕ) : DecidableEq (Vector Bool k) :=
  inferInstance

/--
The probability distribution generated by a `RejectionFilter`.
The probability is uniform over the set of satisfying assignments.
-/
noncomputable def distOfRejectionFilter {k : ℕ} (filter : RejectionFilter k) : Vector Bool k → ℚ :=
  let satisfying_assignments := (Finset.univ : Finset (Vector Bool k)).filter (fun v => evalCNF filter.cnf v = true)
  let num_sat := satisfying_assignments.card
  fun assignment =>
    if evalCNF filter.cnf assignment then
      1 / num_sat
    else
      0


/-!
##############################################################################
  Rationals via Filtered Probability Mass Functions
  ────────────────────────────────────────────────────────────────────────────
  This definitive model constructs rationals from first principles of EGPT and
  probability theory. A rational number is generated by a process defined by:
  1. A `RejectionFilter` that carves out a finite sample space `s` from a
     fair IID source. This creates a uniform PMF over `s`.
  2. A `label` function that partitions `s` into "heads" and "tails" events.
  3. The rational value is the ratio of the total probabilities of these events.

  This directly uses `mathlib`'s `PMF` type for maximum rigor.
##############################################################################
-/


/--
**Step 1: Create the PMF over the filtered event space.**
This function takes the filter and constructs the uniform PMF over its satisfying assignments.
-/
noncomputable def eventsPMF {k : ℕ} (filter : RejectionFilter k) : PMF (Vector Bool k) :=
  let s := (Finset.univ : Finset (Vector Bool k)).filter (fun v => evalCNF filter.cnf v = true)
  -- The probability function f: if v is in s, prob is 1/|s|, else 0.
  -- We use ENNReal as required by PMF.ofFinset.
  let f : Vector Bool k → ENNReal := fun v => if v ∈ s then (s.card : ENNReal)⁻¹ else 0
  -- Proof that the sum of probabilities over s is 1.
  have h_sum_one : ∑ v ∈ s, f v = 1 := by
    -- Simplify the sum: ∑_{v ∈ s} (1/|s|) = |s| * (1/|s|)
    -- Unfold f first
    simp only [f]
    -- Now, for v ∈ s, (if v ∈ s then (↑s.card)⁻¹ else 0) simplifies to (↑s.card)⁻¹.
    -- Then apply sum_const and nsmul_eq_mul.
    rw [Finset.sum_congr rfl fun v hv => if_pos hv, Finset.sum_const, nsmul_eq_mul]
    -- Goal is now (s.card : ENNReal) * (s.card : ENNReal)⁻¹ = 1

    -- Prove s.card ≠ 0 as Nat, then as ENNReal
    -- filter.is_satisfiable (∃ a, evalCNF filter.cnf a = true) implies s.Nonempty
    have h_s_nonempty : s.Nonempty := by
      rcases filter.is_satisfiable with ⟨assignment, h_eval_true⟩
      exact ⟨assignment, Finset.mem_filter.mpr ⟨Finset.mem_univ _, h_eval_true⟩⟩
    have h_s_card_ne_zero_nat : s.card ≠ 0 := by aesop
    have h_s_card_ne_zero_ennreal : (s.card : ENNReal) ≠ 0 := by aesop

    -- Prove s.card ≠ ⊤ as ENNReal (coe from Nat to ENNReal is never ⊤)
    have h_s_card_ne_top_ennreal : (s.card : ENNReal) ≠ ⊤ := ENNReal.coe_ne_top

    -- Apply the cancellation lemma for ENNReal
    rw [ENNReal.mul_inv_cancel h_s_card_ne_zero_ennreal h_s_card_ne_top_ennreal]
    -- Goal is now 1 = 1, which is true by reflexivity (or simp can finish if needed)

  -- Proof that the probability is 0 for any vector not in s.
  have h_zero_outside : ∀ v ∉ s, f v = 0 := by
    intro v hv; simp [f, hv]
  -- Construct the PMF using the mathlib constructor.
  PMF.ofFinset f s h_sum_one h_zero_outside



/-!
##############################################################################
  Rationals as a Partitioned Event Space
  ────────────────────────────────────────────────────────────────────────────
  This definitive EGPT model defines a rational number directly as the result
  of a physical filtering and partitioning process.

  - An EGPT rational is a signed partition of a finite event space into
    "heads events" (numerator) and "tails events" (denominator).
  - Its value is the simple ratio of the sizes of these two sets.
  - The entire structure is encodable as a `GNat`, making it a native EGPT object.
##############################################################################
-/

/--
A `GeneratedRat_PCA` is the EGPT representation of a rational number, defined
as a partitioned set of outcomes from a stochastic process.
-/
structure GeneratedRat_PCA (k : ℕ) where
  /-- The sign of the rational number (true for non-negative). -/
  sign : Bool
  /-- The finite set of k-bit vectors counted as "Heads-Events" (numerator). -/
  heads_events : Finset (Vector Bool k)
  /-- The finite set of k-bit vectors counted as "Tails-Events" (denominator). -/
  tails_events : Finset (Vector Bool k)
  /-- A proof that the denominator event set is non-empty, so the ratio is well-defined. -/
  den_non_empty : tails_events.card > 0
  /-- A proof that the "heads" and "tails" event sets are disjoint. -/
  events_disjoint : Disjoint heads_events tails_events

/--
**`toRat`:** Decodes the abstract mathematical value `p/q` from the partitioned event space.
This function is now remarkably simple and direct.
-/
noncomputable def toRat {k : ℕ} (r : GeneratedRat_PCA k) : ℚ :=
  let p := r.heads_events.card
  let q := r.tails_events.card
  let val : ℚ := mkRat p q
  if r.sign then val else -val

/--
**`fromRat`:** Encodes a standard `ℚ` into a canonical `GeneratedRat_PCA` description.
This constructively builds the partitioned event space.
-/
noncomputable def fromRat (q_in : ℚ) : Σ k : ℕ, GeneratedRat_PCA k :=
  let p := q_in.num.natAbs
  let q := q_in.den
  -- Find a trial size `k` large enough to hold all `p+q` distinct events.
  let k : ℕ := Nat.ceil (Real.logb 2 (↑(p+q) : ℝ))
  -- Get the canonical list of all possible k-bit vectors.
  let all_k_vectors := (Finset.univ : Finset (Vector Bool k)).toList
  ⟨k, {
    sign := (0 ≤ q_in.num),
    heads_events := (all_k_vectors.take p).toFinset,
    tails_events := ((all_k_vectors.drop p).take q).toFinset,
    den_non_empty := by
      -- Since q_in.den > 0, q > 0. The list `(drop p).take q` will have length q.
      -- Its Finset will also have card q, which is > 0.
      simp [List.toFinset_card_of_nodup]
      -- We need to prove the sublist has no duplicates, which is true because `all_k_vectors` has no duplicates.
      -- The main goal after simp is (q ≠ 0 ∧ p < all_k_vectors.length)
      · apply And.intro
        · -- Prove q ≠ 0
          exact Nat.ne_of_gt q_in.den_pos
        · -- Prove p < all_k_vectors.length
          have h_len_ge_pq : all_k_vectors.length ≥ p + q := by
            -- Explicitly simplify all_k_vectors.length to 2^k
            dsimp only [all_k_vectors] -- unfold definition of all_k_vectors in the goal's LHS
            rw [Finset.length_toList] -- Now LHS is (Finset.univ : Finset (Vector Bool k)).card
            rw [Finset.card_univ]     -- Now LHS is Fintype.card (Vector Bool k)
            rw [Fintype.card_congr (listVectorEquivVector.symm : Vector Bool k ≃ List.Vector Bool k)]
            rw [card_vector]  -- Now LHS is Fintype.card Bool ^ k
            rw [Fintype.card_bool]    -- Now LHS is 2 ^ k
            -- At this point, the goal should be (2^k : ℕ) ≥ p + q
            -- The rest of the proof assumes this goal.
            let N_nat := p + q
            let N_real := (N_nat : ℝ)
            have h_N_real_pos : N_real > 0 := by
              exact Nat.cast_pos.mpr (add_pos_of_nonneg_of_pos (Nat.zero_le p) q_in.den_pos)
              --simp [add_pos_of_nonneg_of_pos, (Nat.zero_le p), q_in.den_pos]
            -- k is Nat.ceil (Real.logb 2 N_real)
            -- Goal after simp is 2^k ≥ N_nat (where N_nat = p+q).
            -- We will prove this by showing (↑N_nat : ℝ) ≤ (↑(2^k) : ℝ).
            rw [ge_iff_le] -- Goal: N_nat ≤ 2^k
            -- Then, cast to ℝ.
            rw [← Nat.cast_le (α := ℝ)] -- Goal: (↑N_nat : ℝ) ≤ (↑(2^k) : ℝ)
            calc
              (N_nat : ℝ) = N_real := rfl
              _ ≤ 2 ^ (Real.logb 2 N_real) := by
                rw [Real.rpow_logb (by norm_num) (by norm_num) h_N_real_pos];
              _ ≤ 2 ^ (k : ℝ) := by -- k is Nat.ceil (Real.logb 2 N_real)
                apply Real.rpow_le_rpow_of_exponent_le (by norm_num)
                exact Nat.le_ceil (Real.logb 2 N_real)
              _ = (↑(2^k) : ℝ) := by
                rw [Real.rpow_natCast] -- LHS becomes (2 : ℝ) ^ k
                --rw [Nat.cast_pow]      -- RHS becomes (↑(2 : ℕ) : ℝ) ^ k
                --rw [Nat.cast_two]       -- RHS becomes (2 : ℝ) ^ k
            aesop
          calc
            p < p + q := Nat.lt_add_of_pos_right q_in.den_pos
            _ ≤ all_k_vectors.length := h_len_ge_pq

    events_disjoint := by
      -- The finsets are disjoint because their underlying lists are disjoint.
      simp [disjoint_iff, List.disjoint_take_drop]
  }⟩

-- The equivalence now relates the dependent pair `Σ k : ℕ, GeneratedRat_PCA k` to `ℚ`.
-- As before, a fully formal equivalence requires quotienting over different representations
-- (e.g., p=1,q=1 vs p=2,q=2), but the `toRat`/`fromRat` pair provides the core bijection
-- between `ℚ` and a *canonical* set of EGPT descriptions.
