import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.SpecialFunctions.Log.Basic
import Mathlib.Data.Rat.Defs
import Mathlib.Data.List.Basic
import PprobablyEqualsNP.PartitionTheoryDefs -- Assuming this file is available

/-! RotaEntropyProof.lean -/

namespace PprobablyEqualsNP.RotaEntropyProof

open Classical Real List PprobablyEqualsNP.PartitionTheoryDefs

-- === Definition of f(n) ===

-- === Definition of f(n) ===


/-- The function f(n) = H applied to the uniform distribution on n elements. -/
noncomputable def f (H : EntropyFunction) (n : Nat) : Real :=
  if 0 < n then H (uniformDist n) else 0

lemma f_def_alt {H : EntropyFunction} {n : Nat} (hn : 0 < n) : f H n = H (uniformDist n) := by
  rw [f, if_pos hn]

@[simp] lemma length_uniformDist (n : Nat) : length (uniformDist n) = n := by
  cases n <;> simp [uniformDist]

lemma f_one_is_zero {H : EntropyFunction} (hProps : HasEntropyProperties H) : f H 1 = 0 := by
  have h_unif_1 : uniformDist 1 = [1] := by simp [uniformDist]
  rw [f_def_alt]
  · rw [h_unif_1]; exact hProps.prop0
  · exact Nat.zero_lt_one


-- === Helper Lemmas (Explicit Types) ===

/-- Helper: filter (fun x : Real => decide (x > 0.0)) on uniformDist n is identity for n > 0. -/
lemma filter_decide_gt_zero_uniformDist_eq_self {n : Nat} (hn : 0 < n) :
    filter (fun x : Real => decide (x > 0.0)) (uniformDist n) = uniformDist n := by
  apply filter_eq_self.mpr
  intro x hx_mem
  simp only [uniformDist] at hx_mem
  cases n with
  | zero => exact (Nat.not_lt_zero 0 hn).elim
  | succ k =>
    simp only [mem_replicate] at hx_mem
    obtain ⟨_hnz, hx_eq⟩ := hx_mem
    rw [hx_eq, decide_eq_true_iff] -- Goal: 1 / (↑k + 1) > 0.0

    -- Prove 1 / (↑k + 1) > 0.0
    -- Prove denominator is positive
    have h_den_pos : (↑k + 1 : Real) > 0.0 := by
      linarith [Nat.zero_le k]

    -- Apply the rule 1 / x > 0 if x > 0
    apply one_div_pos
    exact h_den_pos

-- === Main Proof for f_non_decreasing ===

/-- Lemma: f is non-decreasing. Follows from Properties 2 and 5. -/
lemma f_non_decreasing {H : EntropyFunction} (hProps : HasEntropyProperties H) (n : Nat) : f H n ≤ f H (n + 1) := by
  have hn_succ_pos : 0 < n + 1 := Nat.succ_pos n
  rw [f_def_alt hn_succ_pos]
  cases n with
  | zero =>
    simp only [f, dif_neg (Nat.not_lt_zero 0)]
    rw [← f_one_is_zero hProps]
    rfl
  | succ k =>
    have nk_pos : 0 < k + 1 := Nat.succ_pos k
    rw [f_def_alt nk_pos]
    let p := uniformDist (k+1)
    have hp_dist : IsProbDist p := uniformDist_IsProbDist (k+1) nk_pos
    have hp_len_pos : 0 < p.length := by simp [nk_pos]

    let p' := p ++ [0.0] -- Use 0.0 for Real type
    have hp'_dist : IsProbDist p' := by
      constructor
      · intro pi hpi_mem; rw [mem_append] at hpi_mem
        cases hpi_mem with | inl hp => exact hp_dist.1 pi hp | inr h0 => rw [mem_singleton.mp h0]; norm_num
      · rw [sum_append, sum_singleton, hp_dist.2]; norm_num -- Corrected proof for sum

    have hp'_len_val : p'.length = k + 2 := by simp
    have hp'_len_pos : 0 < p'.length := by rw [hp'_len_val]; positivity

    -- Apply Prop 5
    have h_p'_le_unif : H p' ≤ H (uniformDist p'.length) :=
      hProps.prop5 p' hp'_dist hp'_len_pos
    rw [hp'_len_val] at h_p'_le_unif

    -- Apply Prop 2 - Ensure predicate matches EXACTLY
    -- If prop2 definition uses (· > 0), it implicitly becomes (fun x => decide (x > 0))
    have h_p'_eq_filter : H p' = H (p'.filter (fun x : Real => decide (x > 0))) := Eq.symm (hProps.prop2 p' hp'_dist)

    -- Show filter p' (>0) = p using helper lemmas (Explicit Types & Convert)
    have h_filter_eq_p : p'.filter (fun x : Real => decide (x > 0.0)) = p := by -- USE 0.0 here
      -- State 1: Unfold p'
      simp only [p'] -- Goal: filter (...) (p ++ [0.0]) = p
      -- State 2: Apply filter_append
      rw [filter_append] -- Goal: filter (...) p ++ filter (...) [0.0] = p
      -- State 3: Apply the zero filter lemma using convert
      -- Make sure the predicate in convert_to EXACTLY matches the lemma
      convert_to filter (fun x : Real => decide (x > 0.0)) p ++ [] = p using 2
      · -- Prove the sub-goal generated by convert: filter (...) [0.0] = []
        -- This goal now matches the lemma because convert_to used the right predicate
        exact filter_decide_gt_zero_singleton_zero
      -- State 4: append_nil (convert should leave goal as filter (...) p ++ [] = p)
      rw [append_nil] -- Goal: filter (...) p = p
      -- State 5: Apply the uniform dist filter lemma
      -- Make sure this helper lemma ALSO uses > 0.0 if needed, or that Lean unifies 0 and 0.0 here
      rw [filter_decide_gt_zero_uniformDist_eq_self nk_pos] -- Goal: p = p
      -- rfl -- Goal is now p = p, closed by refl
    -- Combine
    -- Use simp or Eq.trans for robustness
    have h_p'_eq_Hp : H p' = H p := by simp [h_p'_eq_filter, h_filter_eq_p]
    -- Alternative: have h_p'_eq_Hp : H p' = H p := Eq.trans h_p'_eq_filter (congrArg H h_filter_eq_p)

    rw [h_p'_eq_Hp] at h_p'_le_unif
    exact h_p'_le_unif

/-- Lemma: f(n) ≥ 0 for n > 0. Follows from f(1)=0 and non-decreasing. -/
lemma f_nonneg {H : EntropyFunction} (hProps : HasEntropyProperties H) (n : Nat) (hn : 0 < n) : 0 ≤ f H n := by
  have h_f1_zero := f_one_is_zero hProps
  rw [← h_f1_zero] -- Goal: f H 1 ≤ f H n
  have step (k : Nat) (_ : 1 ≤ k) (h_ind : f H 1 ≤ f H k) : f H 1 ≤ f H (k + 1) := by
      exact le_trans h_ind (f_non_decreasing hProps k)
  exact Nat.le_induction (le_refl (f H 1)) step n (Nat.one_le_of_lt hn)

-- === Key Consequence of Property 4 ===
axiom EntropyProperty4_Consequence_f {H : EntropyFunction} (hProps : HasEntropyProperties H) :
  ∀ (n k : Nat), (1 < n) → (0 < k) → f H (n^k) = k * f H n

-- === Derivation f(n) = C * log₂(n) ===
axiom f_is_log {H : EntropyFunction} (hProps : HasEntropyProperties H) :
  ∃ C : Real, (0 ≤ C) ∧ (∀ n > 1, f H n = C * logb 2 n)

noncomputable def constant_C (H : EntropyFunction) (hProps : HasEntropyProperties H) : Real :=
  Classical.choose (f_is_log hProps)

lemma constant_C_spec {H : EntropyFunction} (hProps : HasEntropyProperties H) :
   0 ≤ constant_C H hProps ∧ ∀ n > 1, f H n = constant_C H hProps * logb 2 n := by
  exact Classical.choose_spec (f_is_log hProps)

lemma constant_C_nonneg {H : EntropyFunction} (hProps : HasEntropyProperties H) :
   0 ≤ constant_C H hProps := (constant_C_spec hProps).1

lemma f_eq_C_log {H : EntropyFunction} (hProps : HasEntropyProperties H) (n : Nat) (hn : 1 < n) :
   f H n = constant_C H hProps * logb 2 n :=
  (constant_C_spec hProps).2 n hn

-- === Extension to Rational Probabilities ===
axiom Entropy_for_Rational_Probs {H : EntropyFunction} (hProps : HasEntropyProperties H) :
  ∀ (p : List Real) (hp_rat : ∀ pi ∈ p, ∃ q : Rat, pi = q)
    (hp_dist : IsProbDist p),
    H p = constant_C H hProps * ShannonEntropyFunc p

-- === Axiom: Continuity Allows Extension from Rationals to Reals ===
axiom ContinuityExtendsToReals {H : EntropyFunction} (hProps : HasEntropyProperties H) (C : Real) :
  (∀ (p : List Real) (hp_rat : ∀ pi ∈ p, ∃ q : Rat, pi = q) (hp_dist : IsProbDist p),
     H p = C * ShannonEntropyFunc p)
  →
  (∀ (p : List Real) (hp_dist : IsProbDist p), H p = C * ShannonEntropyFunc p)

-- === Uniqueness Theorem ===
theorem UniquenessOfEntropy {H : EntropyFunction} (hProps : HasEntropyProperties H) :
    ∃ C : Real, (0 ≤ C) ∧ (∀ p, IsProbDist p → H p = C * ShannonEntropyFunc p) := by
  let C := constant_C H hProps
  use C
  apply And.intro (constant_C_nonneg hProps)
  apply ContinuityExtendsToReals hProps C
  exact Entropy_for_Rational_Probs hProps

/-- Placeholder justification lemma -/
lemma RotaTheoremJustifiesReduction : True := trivial -- Placeholder

end PprobablyEqualsNP.RotaEntropyProof
