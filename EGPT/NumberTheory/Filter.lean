import Mathlib.Data.Vector.Basic
import Mathlib.Data.Rat.Lemmas
import Mathlib.Data.Fin.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Fintype.Pi
import Mathlib.Data.Fintype.Vector -- Add this import
import Mathlib.Data.Finset.Basic
import Mathlib.Logic.Equiv.Array
import Mathlib.Probability.ProbabilityMassFunction.Basic -- Add this import
import Mathlib.Probability.ProbabilityMassFunction.Constructions -- Add this import
import Mathlib.Probability.ProbabilityMassFunction.Monad -- Add this import
import Mathlib.Data.NNRat.BigOperators
import Mathlib.Control.Random
import EGPT.NumberTheory.Core
import EGPT.Constraints
namespace EGPT.NumberTheory.Filter

open EGPT.NumberTheory.Core EGPT.Constraints
/-!
# EGPT: Stochastic Filters, CNF Constraints, and Biised IID Sources

This file extends the EGPT number theory to formalize the concept of a "filter"
that acts on a fair, fundamental IID source to produce a new, biased IID source.

The core ideas are:
1.  **Filters as Information:** A filter is a computable object, a set of
    constraints represented by a `RandomWalk` via an encoding of a CNF formula.
    This aligns with the EGPT principle that physical laws are computable information.

2.  **Creating Bias through Information Loss:** The filter operates by rejection
    sampling. It observes samples from the fair source and only "passes" those
    that satisfy its constraints. This many-to-one mapping (many source states
    are rejected, a few are accepted) is the mechanism of information loss that
    creates a new, non-uniform (biased) probability distribution.

3.  **Universality:** We show that this mechanism is universal. Any computable
    rational probability distribution can be generated by applying a sufficiently
    complex filter to the fundamental fair source. The complexity of the filter
    is directly tied to the complexity of the distribution it generates.

This provides a constructive bridge between the uniform chaos of the base IID source
and the structured, biased probabilities observed in complex physical and
computational systems.
-/

/- Equivalence between the `List.Vector` type used by `Equiv.vectorEquivFin`
    and the `Vector` type (array‐based) that we use for bit blocks. -/
def listVectorEquivVector {α} {n : ℕ} :
    List.Vector α n ≃ Vector α n :=
{ toFun := fun v =>
    match v with
    | ⟨l, hl⟩ =>
        -- Convert the list to an array and transport the length proof.
        have h_size : (l.toArray).size = n := by
          -- `Array.size_eq_length_toList` tells us the size equals the length of `toList`;
          -- `Array.toList` of `l.toArray` is just `l`.
          simp [Array.size_eq_length_toList, Array.toArray_toList, hl]
        -- Build the `Vector` using the array plus its size proof.
        ⟨l.toArray, h_size⟩,
  invFun := fun v =>
    match v with
    | ⟨a, ha⟩ =>
        -- Convert the array back to a list and transport the length proof.
        have h_len : (a.toList).length = n := by
          -- `ha : a.size = n`, and `Array.size_eq_length_toList` rewrites the size.
          aesop
        ⟨a.toList, h_len⟩,
  left_inv := by
    intro v
    cases v with
    | mk l hl =>
        -- Unfold the constructions; everything reduces to identities on `Array`/`List`.
        simp [Array.size_eq_length_toList, hl],
  right_inv := by
    intro v
    cases v with
    | mk a ha =>
        simp [Array.size_eq_length_toList, ha] }

/-- `Vector Bool k` inherits its `Fintype` structure by transporting the
    canonical `Fintype` on `Fin k → Bool` across the composite equivalence
    ```
    Fin k → Bool  ≃  List.Vector Bool k  ≃  Vector Bool k
    ``` -/
instance instFintypeVectorBool (k : ℕ) : Fintype (Vector Bool k) :=
  Fintype.ofEquiv (Fin k → Bool)
    ((Equiv.vectorEquivFin Bool k).symm.trans listVectorEquivVector)







-- To handle sources that emit blocks of bits (vectors) instead of single bits.
abbrev IIDBlockSource (α : Type) := IIDParticleSource α

-- A fair source that produces k-bit vectors, where each vector is equiprobable.
-- This can be constructed by calling a single-bit IIDParticleSource k times.
instance FairBlockSource (k : ℕ) : IIDBlockSource (Vector Bool k) where
  stream := fun n =>
    let baseSource := mkPseudoRandomSource (seed := n)
    -- Generate a k-length list of Bools and convert to a vector
    Vector.ofFn (fun i : Fin k => baseSource.stream i.val)



/-!
### Section 2: The Rejection Filter (Uniform Distribution over SAT)

This model represents a filter that accepts any input satisfying its CNF constraints.
The resulting distribution is uniform over the set of satisfying assignments.
-/

/--
A `RejectionFilter` encapsulates a CNF formula, which is encodable as a `RandomWalk`.
This structure represents the physical laws or constraints of a system.
-/
-- In EGPT/NumberTheory/Filter.lean

-- ... inside the RejectionFilter definition ...
@[ext]
structure RejectionFilter (k : ℕ) where
  cnf : SyntacticCNF_EGPT k
  satisfying_assignments : Finset (Vector Bool k) :=
    (Finset.univ : Finset (Vector Bool k)).filter (fun v => evalCNF cnf v)
  is_satisfiable : satisfying_assignments.Nonempty
  ax_coherent : ∀ v, v ∈ satisfying_assignments → (evalCNF cnf v = true) := by
    -- Default proof for ax_coherent:
    -- Assumes satisfying_assignments is the default value.
    -- If `v ∈ (Finset.univ).filter (fun x => evalCNF cnf x)`, then `evalCNF cnf v = true`.
    intros v h_v_in_sa
    exact (Finset.mem_filter.mp h_v_in_sa).2

-- Helper to get a witness from a RejectionFilter's proof of non-emptiness
noncomputable def RejectionFilter.get_witness {k : ℕ} (filter : RejectionFilter k) :
  { v : Vector Bool k // evalCNF filter.cnf v = true } :=
  let v := filter.is_satisfiable.choose
  ⟨v, filter.ax_coherent v filter.is_satisfiable.choose_spec⟩

/--
This lemma allows `simp` to unfold the definition of the `satisfying_assignments` field.
It states that when a `RejectionFilter` is built with the default value for this field,
the field is equal to that default value.
-/
@[simp]
lemma satisfying_assignments_def {k} (c : SyntacticCNF_EGPT k) (s) (h) (ax) : -- Added ax
    (RejectionFilter.mk c s h ax).satisfying_assignments = s := rfl

/--
The `RejectionFilter.of_satisfying_example` constructor takes a CNF and a single
satisfying assignment and bundles them into a `RejectionFilter` object.
-/
def RejectionFilter.of_satisfying_example {k : ℕ} (cnf : SyntacticCNF_EGPT k) (solution_example : Vector Bool k) (h_ex : evalCNF cnf solution_example = true) : RejectionFilter k :=
  { cnf := cnf,
    is_satisfiable := ⟨solution_example, by {
        -- Prove the example is in the satisfying_assignments finset
        simp only [satisfying_assignments_def, Finset.mem_filter]
        exact ⟨Finset.mem_univ _, h_ex⟩
      }⟩
  }


instance instDecidableEqVectorBool (k : ℕ) : DecidableEq (Vector Bool k) :=
  inferInstance

/--
The probability distribution generated by a `RejectionFilter`.
The probability is uniform over the set of satisfying assignments.
-/
noncomputable def distOfRejectionFilter {k : ℕ} (filter : RejectionFilter k) : Vector Bool k → ℚ :=
  let satisfying_assignments := (Finset.univ : Finset (Vector Bool k)).filter (fun v => evalCNF filter.cnf v = true)
  let num_sat := satisfying_assignments.card
  fun assignment =>
    if evalCNF filter.cnf assignment then
      1 / num_sat
    else
      0


/-!
##############################################################################
  Rationals via Filtered Probability Mass Functions
  ────────────────────────────────────────────────────────────────────────────
  This definitive model constructs rationals from first principles of EGPT and
  probability theory. A rational number is generated by a process defined by:
  1. A `RejectionFilter` that carves out a finite sample space `s` from a
     fair IID source. This creates a uniform PMF over `s`.
  2. A `label` function that partitions `s` into "heads" and "tails" events.
  3. The rational value is the ratio of the total probabilities of these events.

  This directly uses `mathlib`'s `PMF` type for maximum rigor.
      Voltage (+) ────┬─── Literal X1 ────┐
                      │                   │
                      ├─── Literal ¬X2 ───┤
                      │                   │─── Clause Output Line
                      └─── Literal X3 ────┘

 Voltage (+) ── Clause1 ── Clause2 ── Clause3 ──> Final Output Line

##############################################################################
-/


/--
**Step 1: Create the PMF over the filtered event space.**
This function takes the filter and constructs the uniform PMF over its satisfying assignments.
-/
noncomputable def eventsPMF {k : ℕ} (filter : RejectionFilter k) : PMF (Vector Bool k) :=
  let s := (Finset.univ : Finset (Vector Bool k)).filter (fun v => evalCNF filter.cnf v = true)
  -- The probability function f: if v is in s, prob is 1/|s|, else 0.
  -- We use ENNReal as required by PMF.ofFinset.
  let f : Vector Bool k → ENNReal := fun v => if v ∈ s then (s.card : ENNReal)⁻¹ else 0
  -- Proof that the sum of probabilities over s is 1.
  have h_sum_one : ∑ v ∈ s, f v = 1 := by
    -- Simplify the sum: ∑_{v ∈ s} (1/|s|) = |s| * (1/|s|)
    -- Unfold f first
    simp only [f]
    -- Now, for v ∈ s, (if v ∈ s then (↑s.card)⁻¹ else 0) simplifies to (↑s.card)⁻¹.
    -- Then apply sum_const and nsmul_eq_mul.
    rw [Finset.sum_congr rfl fun v hv => if_pos hv, Finset.sum_const, nsmul_eq_mul]
    -- Goal is now (s.card : ENNReal) * (s.card : ENNReal)⁻¹ = 1

    -- Tactical Note for rewriting cardinalities:
    -- Suppose the goal contains `(#{some_set})` (which is `Set.ncard some_set`),
    -- and you have a hypothesis `h_eq_finset : some_set.toFinset = other_finset`.
    -- To rewrite `(#{some_set})` to `(other_finset.card)`:
    -- 1. First, expose the `.toFinset` expression in the goal:
    --    `rw [Set.ncard_def]` or `simp only [Set.ncard_def]`
    --    This will change `#{some_set}` into `(some_set.toFinset).card`.
    -- 2. Then, use your hypothesis:
    --    `rw [h_eq_finset]`
    --    This will change `(some_set.toFinset).card` into `(other_finset.card)`.
    --
    -- For example, if `S_set` is a set and `S_filter_finset` is a finset,
    -- and you have `h_S_set_toFinset_eq_S_filter_finset : S_set.toFinset = S_filter_finset`.
    -- If your goal is `(↑(#{S_set}))⁻¹`, you would apply:
    --   `simp only [Set.ncard_def]` (or `rw [Set.ncard_def]`)
    --   `rw [h_S_set_toFinset_eq_S_filter_finset]`
    -- These rewrites might need to be targeted using `conv` or `nth_rewrite` if they
    -- occur in subexpressions or if `rw` is too aggressive.

    -- Prove s.card ≠ 0 as Nat, then as ENNReal
    -- filter.is_satisfiable (now filter.satisfying_assignments.Nonempty) implies s.Nonempty
    have h_s_nonempty : s.Nonempty := by
      -- filter.is_satisfiable is filter.satisfying_assignments.Nonempty.
      -- rcases gives an 'assignment' and proof 'h_mem: assignment ∈ filter.satisfying_assignments'.
      rcases filter.is_satisfiable with ⟨assignment, h_mem_sa⟩
      -- We need to show s.Nonempty, so we provide 'assignment' and a proof that 'assignment ∈ s'.
      -- 's' is defined using `evalCNF filter.cnf v = true`.
      -- We use `filter.ax_coherent` to prove `evalCNF filter.cnf assignment = true`.
      have h_eval_true : evalCNF filter.cnf assignment = true :=
        filter.ax_coherent assignment h_mem_sa
      exact ⟨assignment, Finset.mem_filter.mpr ⟨Finset.mem_univ _, h_eval_true⟩⟩
    have h_s_card_ne_zero_nat : s.card ≠ 0 := by aesop
    have h_s_card_ne_zero_ennreal : (s.card : ENNReal) ≠ 0 := by aesop

    -- Prove s.card ≠ ⊤ as ENNReal (coe from Nat to ENNReal is never ⊤)
    have h_s_card_ne_top_ennreal : (s.card : ENNReal) ≠ ⊤ := ENNReal.coe_ne_top

    -- Apply the cancellation lemma for ENNReal
    rw [ENNReal.mul_inv_cancel h_s_card_ne_zero_ennreal h_s_card_ne_top_ennreal]
    -- Goal is now 1 = 1, which is true by reflexivity (or simp can finish if needed)

  -- Proof that the probability is 0 for any vector not in s.
  have h_zero_outside : ∀ v ∉ s, f v = 0 := by
    intro v hv; simp [f, hv]
  -- Construct the PMF using the mathlib constructor.
  PMF.ofFinset f s h_sum_one h_zero_outside


/--
**Constructs the RejectionFilter representing the complete solution space for a
set of physical constraints.**
The core EGPT
claim is that the time required for a physical, non-deterministic process to
find a *single* solution is polynomially equivalent to the time required for
this function to characterize the *entire* solution space.
-/
noncomputable def construct_real_solution_space {k : ℕ} (constraints : CanonicalCNF k) : Option (RejectionFilter k) :=
  -- 1. Deterministically find ALL satisfying assignments by filtering the
  --    entire state space (Finset.univ) against the constraint checker.
  let satisfying_assignments := (Finset.univ : Finset (Vector Bool k)).filter (fun v => evalCNF constraints v)

  -- 2. Check if the resulting set of solutions is empty.
  if h_nonempty : satisfying_assignments.Nonempty then
    -- 3a. If solutions exist, package the complete solution space into a RejectionFilter.
    --     The `is_satisfiable` proof is directly provided by `h_nonempty`.
    let filter : RejectionFilter k := {
      cnf := constraints,
      satisfying_assignments := satisfying_assignments,
      is_satisfiable := h_nonempty,
      -- The coherence axiom is true by the definition of our filter.
      ax_coherent := by
        intros v h_v_in_sa
        -- If v is in the filtered set, it must satisfy the filter's predicate.
        exact (Finset.mem_filter.mp h_v_in_sa).2
    }
    some filter
  else
    -- 3b. If the set of solutions is empty, the system is unsolvable.
    none
