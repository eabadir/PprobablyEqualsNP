import EGPT.NumberTheory.Core
import EGPT.Complexity.Core
import Mathlib.Data.Vector.Basic
import Mathlib.Data.Rat.Lemmas
import Mathlib.Data.Fin.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Fintype.Pi
import Mathlib.Data.Fintype.Vector -- Add this import
import Mathlib.Data.Finset.Basic
import Mathlib.Logic.Equiv.Array
import Mathlib.Probability.ProbabilityMassFunction.Basic -- Add this import
import Mathlib.Probability.ProbabilityMassFunction.Constructions -- Add this import
import Mathlib.Probability.ProbabilityMassFunction.Monad -- Add this import
import Mathlib.Data.NNRat.BigOperators
import Mathlib.Control.Random




open Classical

/- Equivalence between the `List.Vector` type used by `Equiv.vectorEquivFin`
    and the `Vector` type (array‐based) that we use for bit blocks. -/
private def listVectorEquivVector {α} {n : ℕ} :
    List.Vector α n ≃ Vector α n :=
{ toFun := fun v =>
    match v with
    | ⟨l, hl⟩ =>
        -- Convert the list to an array and transport the length proof.
        have h_size : (l.toArray).size = n := by
          -- `Array.size_eq_length_toList` tells us the size equals the length of `toList`;
          -- `Array.toList` of `l.toArray` is just `l`.
          simp [Array.size_eq_length_toList, Array.toArray_toList, hl]
        -- Build the `Vector` using the array plus its size proof.
        ⟨l.toArray, h_size⟩,
  invFun := fun v =>
    match v with
    | ⟨a, ha⟩ =>
        -- Convert the array back to a list and transport the length proof.
        have h_len : (a.toList).length = n := by
          -- `ha : a.size = n`, and `Array.size_eq_length_toList` rewrites the size.
          aesop
        ⟨a.toList, h_len⟩,
  left_inv := by
    intro v
    cases v with
    | mk l hl =>
        -- Unfold the constructions; everything reduces to identities on `Array`/`List`.
        simp [Array.size_eq_length_toList, hl],
  right_inv := by
    intro v
    cases v with
    | mk a ha =>
        simp [Array.size_eq_length_toList, ha] }

/-- `Vector Bool k` inherits its `Fintype` structure by transporting the
    canonical `Fintype` on `Fin k → Bool` across the composite equivalence
    ```
    Fin k → Bool  ≃  List.Vector Bool k  ≃  Vector Bool k
    ``` -/
instance instFintypeVectorBool (k : ℕ) : Fintype (Vector Bool k) :=
  Fintype.ofEquiv (Fin k → Bool)
    ((Equiv.vectorEquivFin Bool k).symm.trans listVectorEquivVector)



/-!
# EGPT: Stochastic Filters, CNF Constraints, and Biised IID Sources

This file extends the EGPT number theory to formalize the concept of a "filter"
that acts on a fair, fundamental IID source to produce a new, biased IID source.

The core ideas are:
1.  **Filters as Information:** A filter is a computable object, a set of
    constraints represented by a `ParticlePath` via an encoding of a CNF formula.
    This aligns with the EGPT principle that physical laws are computable information.

2.  **Creating Bias through Information Loss:** The filter operates by rejection
    sampling. It observes samples from the fair source and only "passes" those
    that satisfy its constraints. This many-to-one mapping (many source states
    are rejected, a few are accepted) is the mechanism of information loss that
    creates a new, non-uniform (biased) probability distribution.

3.  **Universality:** We show that this mechanism is universal. Any computable
    rational probability distribution can be generated by applying a sufficiently
    complex filter to the fundamental fair source. The complexity of the filter
    is directly tied to the complexity of the distribution it generates.

This provides a constructive bridge between the uniform chaos of the base IID source
and the structured, biased probabilities observed in complex physical and
computational systems.
-/

namespace EGPT.NumberTheory.Filter

open EGPT.NumberTheory.Core EGPT.Complexity

-- To handle sources that emit blocks of bits (vectors) instead of single bits.
abbrev IIDBlockSource (α : Type) := IIDParticleSource α

-- A fair source that produces k-bit vectors, where each vector is equiprobable.
-- This can be constructed by calling a single-bit IIDParticleSource k times.
instance FairBlockSource (k : ℕ) : IIDBlockSource (Vector Bool k) where
  stream := fun n =>
    let baseSource := mkPseudoRandomSource (seed := n)
    -- Generate a k-length list of Bools and convert to a vector
    Vector.ofFn (fun i : Fin k => baseSource.stream i.val)

/-!
### Section 1: Syntactic Filters as CNF Formulas

We reuse the syntactic CNF definitions from `Program.lean`. A filter *is* a
CNF formula, represented by a `ParticlePath`. We define an explicit evaluation function
for these syntactic formulas on boolean vectors.
-/

/--
Evaluates a single syntactic literal against a variable assignment vector.
`assignment.get lit.box_index` fetches the boolean value for the variable.
The literal's polarity determines if we use the value directly or its negation.
-/
def evalLiteral {k : ℕ} (lit : Literal_EGPT k) (assignment : Vector Bool k) : Bool :=
  -- `(assignment.get lit.box_index)` is the value of the variable.
  -- `xor` with `¬lit.polarity` implements the conditional negation:
  -- - If polarity is true (positive literal), `¬polarity` is false. `v xor false = v`.
  -- - If polarity is false (negative literal), `¬polarity` is true. `v xor true = ¬v`.
  xor (assignment.get lit.box_index) (not lit.polarity)

/--
Evaluates a syntactic clause. A clause is satisfied if any of its literals are true.
-/
def evalClause {k : ℕ} (clause : Clause_EGPT k) (assignment : Vector Bool k) : Bool :=
  clause.any (fun lit => evalLiteral lit assignment)

/--
Evaluates a syntactic CNF formula. A formula is satisfied if all of its clauses are true.
This function is the semantic interpreter for our filter.
-/
def evalCNF {k : ℕ} (cnf : SyntacticCNF_EGPT k) (assignment : Vector Bool k) : Bool :=
  cnf.all (fun clause => evalClause clause assignment)

/-!
### Section 2: The Rejection Filter (Uniform Distribution over SAT)

This model represents a filter that accepts any input satisfying its CNF constraints.
The resulting distribution is uniform over the set of satisfying assignments.
-/

/--
A `RejectionFilter` encapsulates a CNF formula, which is encodable as a `ParticlePath`.
This structure represents the physical laws or constraints of a system.
-/
structure RejectionFilter (k : ℕ) where
  /-- The syntactic CNF formula representing the filter's rules. -/
  cnf : SyntacticCNF_EGPT k
  /-- A proof that the filter is satisfiable, ensuring the filtered source can produce output. -/
  is_satisfiable : ∃ (assignment : Vector Bool k), evalCNF cnf assignment




instance instDecidableEqVectorBool (k : ℕ) : DecidableEq (Vector Bool k) :=
  inferInstance

/--
The probability distribution generated by a `RejectionFilter`.
The probability is uniform over the set of satisfying assignments.
-/
noncomputable def distOfRejectionFilter {k : ℕ} (filter : RejectionFilter k) : Vector Bool k → ℚ :=
  let satisfying_assignments := (Finset.univ : Finset (Vector Bool k)).filter (fun v => evalCNF filter.cnf v = true)
  let num_sat := satisfying_assignments.card
  fun assignment =>
    if evalCNF filter.cnf assignment then
      1 / num_sat
    else
      0


/-!
##############################################################################
  Rationals via Filtered Probability Mass Functions
  ────────────────────────────────────────────────────────────────────────────
  This definitive model constructs rationals from first principles of EGPT and
  probability theory. A rational number is generated by a process defined by:
  1. A `RejectionFilter` that carves out a finite sample space `s` from a
     fair IID source. This creates a uniform PMF over `s`.
  2. A `label` function that partitions `s` into "heads" and "tails" events.
  3. The rational value is the ratio of the total probabilities of these events.

  This directly uses `mathlib`'s `PMF` type for maximum rigor.
##############################################################################
-/


/--
**Step 1: Create the PMF over the filtered event space.**
This function takes the filter and constructs the uniform PMF over its satisfying assignments.
-/
noncomputable def eventsPMF {k : ℕ} (filter : RejectionFilter k) : PMF (Vector Bool k) :=
  let s := (Finset.univ : Finset (Vector Bool k)).filter (fun v => evalCNF filter.cnf v = true)
  -- The probability function f: if v is in s, prob is 1/|s|, else 0.
  -- We use ENNReal as required by PMF.ofFinset.
  let f : Vector Bool k → ENNReal := fun v => if v ∈ s then (s.card : ENNReal)⁻¹ else 0
  -- Proof that the sum of probabilities over s is 1.
  have h_sum_one : ∑ v ∈ s, f v = 1 := by
    -- Simplify the sum: ∑_{v ∈ s} (1/|s|) = |s| * (1/|s|)
    -- Unfold f first
    simp only [f]
    -- Now, for v ∈ s, (if v ∈ s then (↑s.card)⁻¹ else 0) simplifies to (↑s.card)⁻¹.
    -- Then apply sum_const and nsmul_eq_mul.
    rw [Finset.sum_congr rfl fun v hv => if_pos hv, Finset.sum_const, nsmul_eq_mul]
    -- Goal is now (s.card : ENNReal) * (s.card : ENNReal)⁻¹ = 1

    -- Prove s.card ≠ 0 as Nat, then as ENNReal
    -- filter.is_satisfiable (∃ a, evalCNF filter.cnf a = true) implies s.Nonempty
    have h_s_nonempty : s.Nonempty := by
      rcases filter.is_satisfiable with ⟨assignment, h_eval_true⟩
      exact ⟨assignment, Finset.mem_filter.mpr ⟨Finset.mem_univ _, h_eval_true⟩⟩
    have h_s_card_ne_zero_nat : s.card ≠ 0 := by aesop
    have h_s_card_ne_zero_ennreal : (s.card : ENNReal) ≠ 0 := by aesop

    -- Prove s.card ≠ ⊤ as ENNReal (coe from Nat to ENNReal is never ⊤)
    have h_s_card_ne_top_ennreal : (s.card : ENNReal) ≠ ⊤ := ENNReal.coe_ne_top

    -- Apply the cancellation lemma for ENNReal
    rw [ENNReal.mul_inv_cancel h_s_card_ne_zero_ennreal h_s_card_ne_top_ennreal]
    -- Goal is now 1 = 1, which is true by reflexivity (or simp can finish if needed)

  -- Proof that the probability is 0 for any vector not in s.
  have h_zero_outside : ∀ v ∉ s, f v = 0 := by
    intro v hv; simp [f, hv]
  -- Construct the PMF using the mathlib constructor.
  PMF.ofFinset f s h_sum_one h_zero_outside
